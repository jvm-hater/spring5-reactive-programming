# ****Kevin의 알기 쉬운 RxJava 1-2부 (인프런)****

## 리액티브 연산자 개요 및 연산자 종류

### RxJava의 연산자란?

- RxJava에서의 연산자는 메서드(함수)다.
- 연산자를 이용하여 데이터를 생성하고 통지하는 Flowable이나 Observable 등의 생산자를 생성할 수 있다.
- Flowable이나 Observable에서 통지한 데이터를 다양한 연산자를 사용하여 가공 및 처리하여 결과 값을 만들어 낸다.
- 연산자의 특성에 따라 크게 다음 카테고리로 나뉜다.
    - Flowable/Observable 생성 연산자
    - 통지된 데이터를 필터링해 주는 연산자
    - 통지된 데이터를 변환해 주는 연산자
    - 여러 개의 Flowable/Observable을 결합하는 연산자
    - 에러 처리 연산자
    - 유틸리티 연산자
    - 조건과 불린 연산자
    - 통지된 데이터를 집계해 주는 연산자

### Flowable/Observable 생성 연산자

**interval 연산자**

- 지정한 시간 간격마다 0부터 시작하는 숫자(Long)를 통지한다.
- initialDelay 파라미터를 이용하여 최초 통지에 대한 대기 시간을 지정할 수 있다.
- 완료 없이 계속 통지한다.
- 호출한 스레드와는 별도의 스레드에서 실행된다.
- polling 용도의 작업을 수행할 때 활용할 수 있다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c5e8718d-a406-43e6-93b9-be4d388cb393/Untitled.png)

```java
public class ObservableIntervalExample {
    public static void main(String[] args){
        System.out.println("# start : " +TimeUtil.getCurrentTimeFormatted());

        Observable.interval(1000L, TimeUnit.MILLISECONDS)
                .map(num -> num + " count")
                .subscribe(data -> Logger.log(LogType.ON_NEXT, data));

        TimeUtil.sleep(3000);
    }
}

// 실행 결과
# start : 21:41:38.144
onNext() | RxComputationThreadPool-1 | 21:41:39.340 | 0 count
onNext() | RxComputationThreadPool-1 | 21:41:40.331 | 1 count
onNext() | RxComputationThreadPool-1 | 21:41:41.336 | 2 count
```

**range 연산자**

- 지정한 값(n)부터 m개의 숫자(Integer)를 통지한다.
- for, while문 등의 반복문을 대체할 수 있다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/8c049ac7-4876-4de7-b184-4d2b6e49c1c1/Untitled.png)

```java
public class ObservableRangeExample {
    public static void main(String[] args){
        Observable<Integer> source = Observable.range(0, 5);
        source.subscribe(num -> Logger.log(LogType.ON_NEXT, num));
    }
}

// 실행 결과
onNext() | main | 21:42:44.746 | 0
onNext() | main | 21:42:44.749 | 1
onNext() | main | 21:42:44.749 | 2
onNext() | main | 21:42:44.750 | 3
onNext() | main | 21:42:44.750 | 4
```

**timer 연산자**

- 지정한 시간이 지나면 0(Long)을 통지한다.
- 0을 통지하고 `onComplete()` 이벤트가 발생하여 종료한다.
- 호출한 스레드와는 별도의 스레드에서 실행된다.
- 특정 시간을 대기한 후에 어떤 처리를 하고자 할 때 활용할 수 있다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/dcb01412-9c36-4c44-b627-bc2ae29d6c31/Untitled.png)

```java
public class ObservableTimerExample {
    public static void main(String[] args){
        Logger.log(LogType.PRINT, "# Start!");
        Observable<String> observable =
                Observable.timer(2000, TimeUnit.MILLISECONDS)
                        .map(count -> "Do work!");

        observable.subscribe(data -> Logger.log(LogType.ON_NEXT, data));

        TimeUtil.sleep(3000);
    }
}

// 실행 결과
print() | main | 21:44:05.022 | # Start!
onNext() | RxComputationThreadPool-1 | 21:44:07.192 | Do work!
```

**defer 연산자**

- 구독이 발생할 때마다 즉, `subscribe()` 메서드가 호출될 때마다 새로운 Observable을 생성한다.
- 선언한 시점의 데이터를 통지하는 것이 아니라, 호출 시점의 데이터를 통지한다.
- 데이터 생성을 미루는 효과가 있기 때문에 최신 데이터를 얻고자할 때 활용할 수 있다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c8da104a-d635-4acd-89a9-520faee02e36/Untitled.png)

```java
public class ObservableDeferExample {
    public static void main(String[] args) throws InterruptedException {
        Observable<LocalTime> observable = Observable.defer(() -> {
            LocalTime currentTime = LocalTime.now();
            return Observable.just(currentTime);
        });

        Observable<LocalTime> observableJust = Observable.just(LocalTime.now());

        observable.subscribe(time -> Logger.log(LogType.PRINT, " # defer() 구독1의 구독 시간: " + time));
        observableJust.subscribe(time -> Logger.log(LogType.PRINT, " # just() 구독1의 구독 시간: " + time));

        Thread.sleep(3000);

        observable.subscribe(time -> Logger.log(LogType.PRINT, " # defer() 구독2의 구독 시간: " + time));
        observableJust.subscribe(time -> Logger.log(LogType.PRINT, " # just() 구독자2의 구독 시간: " + time));
    }
}

// 실행 결과
print() | main | 21:45:19.568 |  # defer() 구독1의 구독 시간: 21:45:19.549
print() | main | 21:45:19.571 |  # just() 구독1의 구독 시간: 21:45:19.538
print() | main | 21:45:22.579 |  # defer() 구독2의 구독 시간: 21:45:22.579
print() | main | 21:45:22.580 |  # just() 구독자2의 구독 시간: 21:45:19.538
```

**fromIterable 연산자**

- Iterable 인터페이스를 구현한 클래스를 파라미터로 받는다.
- Iterable에 담긴 데이터를 순서대로 통지한다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/0a1be39c-9ff7-4298-a330-c6eba230e39b/Untitled.png)

```java
public class ObservableFromIterableExample {
    public static void main(String[] args){
        List<String> countries = Arrays.asList("Korea", "Canada", "USA", "Italy");

        Observable.fromIterable(countries)
                .subscribe(country -> Logger.log(LogType.ON_NEXT, country));
    }
}
```

**fromFuture 연산자**

- Future 인터페이스는 자바 5에서 비동기 처리를 위해 추가된 동시성 API이다.
- 시간이 오래 걸리는 작업은 Future를 반환하는 ExecutorService에서 맡기고 비동기로 다른 작업을 수행할 수 있다.
- Java 8에서는 CompletableFuture 클래스를 통해 구현이 간결해졌다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/8e3e040c-a18e-4070-b93b-09d3968a1dd4/Untitled.png)

```java
public class ObservableFromFutureExample {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        Logger.log(LogType.PRINT, "# start time");

        // 긴 처리 시간이 걸리는 작업
        Future<Double> future = longTimeWork();

        // 짧은 처리 시간이 걸리는 작업
        shortTimeWork();

        Observable.fromFuture(future)
                .subscribe(data -> Logger.log(LogType.PRINT, "# 긴 처리 시간 작업 결과 : " + data));

        Logger.log(LogType.PRINT, "# end time");
    }

    public static CompletableFuture<Double> longTimeWork(){
        return CompletableFuture.supplyAsync(() -> calculate());
    }

    private static Double calculate() {
        Logger.log(LogType.PRINT, "# 긴 처리 시간이 걸리는 작업 중.........");
        TimeUtil.sleep(6000L);
        return 100000000000000000.0;
    }

    private static void shortTimeWork() {
        TimeUtil.sleep(3000L);
        Logger.log(LogType.PRINT, "# 짧은 처리 시간 작업 완료!");
    }
}

// 실행 결과
print() | main | 21:47:49.721 | # start time
print() | ForkJoinPool.commonPool-worker-9 | 21:47:49.748 | # 긴 처리 시간이 걸리는 작업 중.........
print() | main | 21:47:52.753 | # 짧은 처리 시간 작업 완료!
print() | main | 21:47:55.759 | # 긴 처리 시간 작업 결과 : 1.0E17
print() | main | 21:47:55.759 | # end time
```

### 데이터 필터링 연산자

**filter 연산자**

- 전달 받은 데이터가 조건에 맞는지 확인한 후, 결과가 true인 데이터만 통지한다.
- filter라는 단어의 사전적 의미가 무언가를 걸러냈다는 의미이다.
- 파라미터로 받는 Predicate 함수형 인터페이스에서 조건을 확인한다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/8b4eb9aa-0f6d-47e1-9ead-2b171de8e7c0/Untitled.png)

```java
public class ObservableFilterExample02 {
    public static void main(String[] args) {
        Observable.fromIterable(SampleData.carList)
                .filter(car -> car.getCarMaker() == CarMaker.CHEVROLET)
                .filter(car -> car.getCarPrice() > 30000000)
                .subscribe(car -> System.out.println(car.getCarName()));
    }
}

// 실행 결과
트래버스
```

**distinct 연산자**

- 이미 통지된 동일한 데이터가 있다면 이후의 동일한 데이터는 통지하지 않는다.
- distinct의 사전적 의미는 `명확하게 구별되는`이라는 뜻을 포함하고 있다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/b5199c0f-f872-4237-a7b8-4c54730e87e0/Untitled.png)

```java
public class ObservableDistinctExample01 {
    public static void main(String[] args) {
        Observable.fromArray(SampleData.carMakersDuplicated)
                .distinct()
                .subscribe(carMaker -> Logger.log(LogType.ON_NEXT, carMaker));
    }
}

// 실행 결과
onNext() | main | 22:15:21.721 | CHEVROLET
onNext() | main | 22:15:21.724 | HYUNDAE
onNext() | main | 22:15:21.724 | SAMSUNG
onNext() | main | 22:15:21.724 | SSANGYOUNG
onNext() | main | 22:15:21.725 | KIA
```

**take 연산자**

- 파라미터로 지정한 개수나 기간이 될 때까지 데이터를 통지한다.
- 지정한 범위가 통지 데이터보다 클 경우 데이터를 모두 통지하고 완료한다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/218c9608-2a45-46ff-88cc-766c078fa50d/Untitled.png)

```java
public class ObservableTakeExample01 {
    public static void main(String[] args) {
        Observable.just("a", "b", "c", "d")
                .take(2)
                .subscribe(data -> Logger.log(LogType.ON_NEXT, data));
    }
}

// 실행 결과
onNext() | main | 22:16:15.205 | a
onNext() | main | 22:16:15.208 | b
```

**takeUntil 연산자 - 첫 번째 유형**

- 파라미터로 지정한 조건이 true가 될 때까지 데이터를 계속 통지한다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/72b748ff-02c3-442c-8cfc-43c36337c083/Untitled.png)

```java
public class ObservableTakeUntilExample01 {
    public static void main(String[] args) {
        Observable.fromIterable(SampleData.carList)
                .takeUntil((Car car) -> car.getCarName().equals("트랙스"))
                .subscribe(car -> System.out.println(car.getCarName()));

        TimeUtil.sleep(300L);
    }
}

// 실행 결과
말리부
쏘렌토
트래버스
팰리세이드
트랙스
```

**takeUntil 연산자 - 두 번째 유형**

- 파라미터로 지정한 Observable이 최초 데이터를 통지할 때까지 데이터를 계속 통지한다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c34d7575-82b9-487f-b11c-8f318f621e19/Untitled.png)

```java
public class ObservableTakeUntilExample02 {
    public static void main(String[] args) {
        Observable.interval(1000L, TimeUnit.MILLISECONDS)
                .takeUntil(Observable.timer(5500L, TimeUnit.MILLISECONDS))
                .subscribe(data -> Logger.log(LogType.ON_NEXT, data));

        TimeUtil.sleep(5500L);
    }
}

// 실행 결과
onNext() | RxComputationThreadPool-2 | 22:18:38.518 | 0
onNext() | RxComputationThreadPool-2 | 22:18:39.478 | 1
onNext() | RxComputationThreadPool-2 | 22:18:40.475 | 2
onNext() | RxComputationThreadPool-2 | 22:18:41.475 | 3
onNext() | RxComputationThreadPool-2 | 22:18:42.475 | 4
```

**skip 연산자 - 첫 번째 유형**

- 파라미터로 지정한 숫자만큼 데이터를 건너뛴 후 나머지 데이터를 통지한다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/dddefd8c-8b98-474c-8b16-a0dfae6156e2/Untitled.png)

```java
public class ObservableSkipExample01 {
    public static void main(String[] args) {
        Observable.range(1, 15)
                .skip(3)
                .subscribe(data -> Logger.log(LogType.ON_NEXT, data));
    }
}

// 실행 결과
onNext() | main | 22:19:34.293 | 4
onNext() | main | 22:19:34.296 | 5
onNext() | main | 22:19:34.296 | 6
onNext() | main | 22:19:34.296 | 7
onNext() | main | 22:19:34.296 | 8
onNext() | main | 22:19:34.296 | 9
onNext() | main | 22:19:34.296 | 10
onNext() | main | 22:19:34.296 | 11
onNext() | main | 22:19:34.296 | 12
onNext() | main | 22:19:34.296 | 13
onNext() | main | 22:19:34.296 | 14
onNext() | main | 22:19:34.296 | 15
```

**skip 연산자 - 두 번째 유형**

- 파라미터로 지정한 시간 동안에는 데이터 통지를 건너뛰고, 지정한 시간이 지난 후 나머지 데이터를 통지한다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5905d96b-df56-4f61-a74f-73b4f399fdf2/Untitled.png)

```java
public class ObservableSkipExample02 {
    public static void main(String[] args) {
        Observable.interval(300L, TimeUnit.MILLISECONDS)
                .skip(1000L, TimeUnit.MILLISECONDS)
                .subscribe(data -> Logger.log(LogType.ON_NEXT, data));

        TimeUtil.sleep(3000L);
    }
}

// 실행 결과
onNext() | RxComputationThreadPool-2 | 22:20:38.027 | 3
onNext() | RxComputationThreadPool-2 | 22:20:38.284 | 4
onNext() | RxComputationThreadPool-2 | 22:20:38.583 | 5
onNext() | RxComputationThreadPool-2 | 22:20:38.884 | 6
onNext() | RxComputationThreadPool-2 | 22:20:39.184 | 7
onNext() | RxComputationThreadPool-2 | 22:20:39.482 | 8
onNext() | RxComputationThreadPool-2 | 22:20:39.783 | 9
```

### 데이터 변환 연산자

**map 연산자**

- 원본 Observable에서 통지하는 데이터를 원하는 값으로 변환 후 통지한다.
- 변환 전, 후 데이터 타입은 달라도 상관 없다.
- null을 반환하면 NullpointException이 발생하므로 null이 아닌 데이터 하나를 반드시 반환해야 한다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/13c914bf-79d2-458d-943c-37205a8ad4c0/Untitled.png)

```java
public class ObservableMapExample01 {
    public static void main(String[] args){
        List<Integer> oddList = Arrays.asList(1, 3, 5, 7);
        Observable.fromIterable(oddList)
                .map(num -> "1을 더한 결과: " + (num + 1))
                .subscribe(data -> Logger.log(LogType.ON_NEXT, data));
    }
}

// 실행 결과
onNext() | main | 22:41:42.226 | 1을 더한 결과: 2
onNext() | main | 22:41:42.230 | 1을 더한 결과: 4
onNext() | main | 22:41:42.230 | 1을 더한 결과: 6
onNext() | main | 22:41:42.230 | 1을 더한 결과: 8
```

**flatMap 연산자 - 첫 번째 유형**

- 원본 데이터를 원하는 값으로 변환 후 통지하는 것은 map과 같다.
- map이 1 대 1 변환인 것과 달리 flatMap은 1 대 다 변환하므로 데이터 1개로 여러 데이터를 통지할 수 있다.
- map은 변환된 데이터를 반환하지만, flatMap은 변환된 여러 개의 데이터를 담고 있는 새로운 Observable을 반환한다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/09c98daf-2081-437b-930b-e80eab952e86/Untitled.png)

```java
public class ObservableFlatMapExample02 {
    public static void main(String[] args){
        Observable.range(2, 1)
                .flatMap(
                        num -> Observable.range(1, 9)
                                         .map(row -> num + " * " + row + " = " + num * row)
                )
                .subscribe(data -> Logger.log(LogType.ON_NEXT, data));
    }
}

// 실행 결과
onNext() | main | 22:44:20.362 | 2 * 1 = 2
onNext() | main | 22:44:20.365 | 2 * 2 = 4
onNext() | main | 22:44:20.365 | 2 * 3 = 6
onNext() | main | 22:44:20.365 | 2 * 4 = 8
onNext() | main | 22:44:20.365 | 2 * 5 = 10
onNext() | main | 22:44:20.365 | 2 * 6 = 12
onNext() | main | 22:44:20.365 | 2 * 7 = 14
onNext() | main | 22:44:20.365 | 2 * 8 = 16
onNext() | main | 22:44:20.365 | 2 * 9 = 18
```

**flatMap 연산자 - 두 번째 유형**

- 원본 데이터와 변환된 데이터를 조합해서 새로운 데이터를 통지한다.
- 즉, Observable에 `원본 데이터 + 변환된 데이터 = 최종 데이터`를 실어서 반환한다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/0d32f7dd-585f-4cbe-95e4-b407a746f49e/Untitled.png)

```java
public class ObservableFlatMapExample03 {
    public static void main(String[] args) {
        Observable.range(2, 1)
                .flatMap(
                        data -> Observable.range(1, 9),
                        (sourceData, transformedData) ->
                                sourceData + " * " + transformedData + " = " + sourceData * transformedData
                )
                .subscribe(data -> Logger.log(LogType.ON_NEXT, data));

    }
}

// 실행 결과
onNext() | main | 22:44:20.362 | 2 * 1 = 2
onNext() | main | 22:44:20.365 | 2 * 2 = 4
onNext() | main | 22:44:20.365 | 2 * 3 = 6
onNext() | main | 22:44:20.365 | 2 * 4 = 8
onNext() | main | 22:44:20.365 | 2 * 5 = 10
onNext() | main | 22:44:20.365 | 2 * 6 = 12
onNext() | main | 22:44:20.365 | 2 * 7 = 14
onNext() | main | 22:44:20.365 | 2 * 8 = 16
onNext() | main | 22:44:20.365 | 2 * 9 = 18
```

- flatMap 첫 번째 유형은 flatMap의 파라미터가 하나였고, 그 파라미터가 데이터 통지 및 map도 수행을 하였다.
- 반면, flatMap 두 번째 유형은 flatMap 파라미터가 두 개이다. 전자는 데이터 통지만 하고, 후자는 원본 데이터와 통지된 데이터들을 이용하여 map을 수행하였다.

**concatMap 연산자**

- flatMap과 마찬가지로 받은 데이터를 변환하여 새로운 Observable로 반환한다.
- 반환된 새로운 Observable을 하나씩 순서대로 실행하는 것이 FlatMap과 다르다.
- 즉, 데이터의 처리 순서는 보장하지만. 처리 중인 Observable의 처리가 끝나야 다음 Observable이 실행되므로 처리 성능에 영향을 줄 수 있다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/0bdcf8e2-abe9-491e-8145-d0c3cdcc0617/Untitled.png)

```java
// flatMap을 사용하는 예제
public class ObservableConcatMapExample01 {
    public static void main(String[] args) {
        TimeUtil.start();
        Observable.interval(100L, TimeUnit.MILLISECONDS)
                .take(4)
                .skip(2)
                .flatMap(
                        num -> Observable.interval(200L, TimeUnit.MILLISECONDS)
                                .take(10)
                                .skip(1)
                                .map(row -> num + " * " + row + " = " + num * row)
                ).subscribe(
                        data -> Logger.log(LogType.ON_NEXT, data),
                        error -> {},
                        () -> {
                            TimeUtil.end();
                            TimeUtil.takeTime();
                        }
                );

        TimeUtil.sleep(5000L);
    }
}

// 실행 결과
onNext() | RxComputationThreadPool-2 | 22:48:28.610 | 2 * 1 = 2
onNext() | RxComputationThreadPool-3 | 22:48:28.681 | 3 * 1 = 3
onNext() | RxComputationThreadPool-2 | 22:48:28.780 | 2 * 2 = 4
onNext() | RxComputationThreadPool-3 | 22:48:28.881 | 3 * 2 = 6
onNext() | RxComputationThreadPool-2 | 22:48:28.979 | 2 * 3 = 6
onNext() | RxComputationThreadPool-3 | 22:48:29.081 | 3 * 3 = 9
onNext() | RxComputationThreadPool-2 | 22:48:29.183 | 2 * 4 = 8
onNext() | RxComputationThreadPool-3 | 22:48:29.281 | 3 * 4 = 12
onNext() | RxComputationThreadPool-2 | 22:48:29.383 | 2 * 5 = 10
onNext() | RxComputationThreadPool-3 | 22:48:29.482 | 3 * 5 = 15
onNext() | RxComputationThreadPool-2 | 22:48:29.587 | 2 * 6 = 12
onNext() | RxComputationThreadPool-3 | 22:48:29.681 | 3 * 6 = 18
onNext() | RxComputationThreadPool-2 | 22:48:29.783 | 2 * 7 = 14
onNext() | RxComputationThreadPool-3 | 22:48:29.887 | 3 * 7 = 21
onNext() | RxComputationThreadPool-2 | 22:48:29.983 | 2 * 8 = 16
onNext() | RxComputationThreadPool-3 | 22:48:30.081 | 3 * 8 = 24
onNext() | RxComputationThreadPool-2 | 22:48:30.183 | 2 * 9 = 18
onNext() | RxComputationThreadPool-3 | 22:48:30.283 | 3 * 9 = 27
# 실행시간: 2655 ms

// concatMap을 사용하는 예제
public class ObservableConcatMapExample01 {
    public static void main(String[] args) {
        TimeUtil.start();
        Observable.interval(100L, TimeUnit.MILLISECONDS)
                .take(4)
                .skip(2)
                .concatMap(
                        num -> Observable.interval(200L, TimeUnit.MILLISECONDS)
                                .take(10)
                                .skip(1)
                                .map(row -> num + " * " + row + " = " + num * row)
                ).subscribe(
                        data -> Logger.log(LogType.ON_NEXT, data),
                        error -> {},
                        () -> {
                            TimeUtil.end();
                            TimeUtil.takeTime();
                        }
                );

        TimeUtil.sleep(5000L);
    }
}

// 실행 결과
onNext() | RxComputationThreadPool-2 | 22:49:35.300 | 2 * 1 = 2
onNext() | RxComputationThreadPool-2 | 22:49:35.474 | 2 * 2 = 4
onNext() | RxComputationThreadPool-2 | 22:49:35.672 | 2 * 3 = 6
onNext() | RxComputationThreadPool-2 | 22:49:35.870 | 2 * 4 = 8
onNext() | RxComputationThreadPool-2 | 22:49:36.074 | 2 * 5 = 10
onNext() | RxComputationThreadPool-2 | 22:49:36.274 | 2 * 6 = 12
onNext() | RxComputationThreadPool-2 | 22:49:36.474 | 2 * 7 = 14
onNext() | RxComputationThreadPool-2 | 22:49:36.674 | 2 * 8 = 16
onNext() | RxComputationThreadPool-2 | 22:49:36.873 | 2 * 9 = 18
onNext() | RxComputationThreadPool-3 | 22:49:37.279 | 3 * 1 = 3
onNext() | RxComputationThreadPool-3 | 22:49:37.479 | 3 * 2 = 6
onNext() | RxComputationThreadPool-3 | 22:49:37.678 | 3 * 3 = 9
onNext() | RxComputationThreadPool-3 | 22:49:37.879 | 3 * 4 = 12
onNext() | RxComputationThreadPool-3 | 22:49:38.080 | 3 * 5 = 15
onNext() | RxComputationThreadPool-3 | 22:49:38.280 | 3 * 6 = 18
onNext() | RxComputationThreadPool-3 | 22:49:38.479 | 3 * 7 = 21
onNext() | RxComputationThreadPool-3 | 22:49:38.680 | 3 * 8 = 24
onNext() | RxComputationThreadPool-3 | 22:49:38.879 | 3 * 9 = 27
# 실행시간: 4491 ms
```

**switchMap 연산자**

- concatMap과 마찬가지로 받은 데이터를 변환하여 새로운 Observable로 반환한다.
- concatMap과 다른 점은 switchMap은 순서를 보장하지만, 새로운 데이터가 통지되면 현재 처리 중이던 작업을 바로 중단한다.
- 여러 개의 발행된 값 중에 마지막에 들어온 값만 처리하고자할 때 유용하다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/a0e17e26-45e8-4578-ab60-e953a34826e0/Untitled.png)

```java
// 검색 엔진의 키워드 검색 예제 - 임의의 키워드를 입력했을 때 자동 완성 단어를 보여주는 상황
// 가령, 아래 keywords 리스트처럼 요소 M이 들어왔을 때는 M에 대한 자동 완성 단어를 보여줄 것이고
// 요소 Ma가 들어왔을 때는 Ma에 대한 자동 완성을 보여줄 것이다.
// 사용자는 M, Ma, Mal에 대한 자동 완성 단어를 모두 궁금해하지는 않고 키워드를 완성해나가면서
// 앞의 부분 몇 개만 키워드를 볼 확률이 높으므로 마지막에 들어온 값이 중요할 것이다.
public class ObservableSwitchMapExample03 {
    public static void main(String[] args) {
        TimeUtil.start();
        Searcher searcher = new Searcher();
        // 사용자가 입력하는 검색어라고 가정한다.
        final List<String> keywords = Arrays.asList("M", "Ma", "Mal", "Malay");

        Observable.interval(100L, TimeUnit.MILLISECONDS)
                .take(4)
                .doOnNext(data -> Logger.log(LogType.DO_ON_NEXT, data))
                .switchMap(data -> { /** switchMap을 사용했기 때문에 마지막 키워드를 사용한 최신 검색 결과만 가져온다 */
                    String keyword = keywords.get(data.intValue()); // 데이터베이스에서 조회한다고 가정한다.

                    return Observable.just(searcher.search(keyword))
                            .delay(1000L, TimeUnit.MILLISECONDS);
                })
                .flatMap(resultList -> Observable.fromIterable(resultList))
                .subscribe(
                        data -> Logger.log(LogType.ON_NEXT, data),
                        error -> {},
                        () -> {
                            TimeUtil.end();
                            TimeUtil.takeTime();
                        }
                );

        TimeUtil.sleep(2000L);
    }
}

// 실행 결과
doOnNext() | RxComputationThreadPool-1 | 22:53:20.517 | 0
doOnNext() | RxComputationThreadPool-1 | 22:53:20.593 | 1
doOnNext() | RxComputationThreadPool-1 | 22:53:20.693 | 2
doOnNext() | RxComputationThreadPool-1 | 22:53:20.793 | 3
onNext() | RxComputationThreadPool-5 | 22:53:21.805 | Malaysia
# 실행시간: 1639 ms
```

**groupBy 연산자**

- 하나의 Observable을 여러 개의 새로운 GroupedByObservable로 만든다.
- 원본 Observable의 데이터를 그룹 별로 묶는다기보다는 각각의 데이터들이 그룹에 해당하는 Key를 가지게 된다.
- GroupedByObservable은 `getKey()`를 통해 구분된 그룹을 알 수 있게 해 준다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/bf3e3e3c-6326-418c-8aee-be20c2a3da23/Untitled.png)

```java
public class ObservableGroupByExample01 {
    public static void main(String[] args) {
        Observable<GroupedObservable<CarMaker, Car>> observable =
                Observable.fromIterable(SampleData.carList).groupBy(car -> car.getCarMaker());

        observable.subscribe(
                groupedObservable -> groupedObservable.subscribe(
                        car -> Logger.log(
                                LogType.ON_NEXT, "Group: " +
                                        groupedObservable.getKey() +
                                        "\t Car name: " + car.getCarName())
                )
        );

    }
}

// 실행 결과
onNext() | main | 23:07:07.384 | Group: CHEVROLET	 Car name: 말리부
onNext() | main | 23:07:07.388 | Group: HYUNDAE	 Car name: 쏘렌토
onNext() | main | 23:07:07.388 | Group: CHEVROLET	 Car name: 트래버스
onNext() | main | 23:07:07.388 | Group: HYUNDAE	 Car name: 팰리세이드
onNext() | main | 23:07:07.388 | Group: CHEVROLET	 Car name: 트랙스
onNext() | main | 23:07:07.388 | Group: SSANGYOUNG	 Car name: 티볼리
onNext() | main | 23:07:07.388 | Group: SAMSUNG	 Car name: SM6
onNext() | main | 23:07:07.388 | Group: SSANGYOUNG	 Car name: G4렉스턴
onNext() | main | 23:07:07.388 | Group: SAMSUNG	 Car name: SM5
```

**toList 연산자**

- 통지되는 데이터를 모두 List에 담아 통지한다.
- 원본 Observable에서 완료 통지를 받는 즉시 리스트를 통지한다.
- 통지되는 데이터는 원본 데이터를 담은 리스트 하나이므로 Single로 반환된다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/2628ad00-e1fa-4c48-8120-23070a653853/Untitled.png)

```java
public class ObservableToListExample01 {
    public static void main(String[] args) {
        Single<List<Integer>> single = Observable.just(1, 3, 5, 7, 9)
                                                .toList();

        single.subscribe(data -> Logger.log(LogType.ON_NEXT, data));
    }
}

// 실행 결과
onNext() | main | 23:08:19.696 | [1, 3, 5, 7, 9]
```

**toMap 연산자**

- 통지되는 데이터를 모두 담아 통지한다.
- 원본 Observable에서 완료 통지를 받는 즉시 Map을 통지한다.
- 이미 사용 중인 Key를 또 생성하면, 기존에 있던 Key와 Value를 덮어 쓴다.
- 통지되는 데이터는 원본 데이터를 담은 Map 하나이므로 Single로 반환된다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/9a29567c-4b4d-4514-a14a-2d62270bb9a6/Untitled.png)

```java
// 파라미터가 1개
public class ObservableToMapExample01 {
    public static void main(String[] args) {
        Single<Map<String, String>> single =
                Observable.just("a-Alpha", "b-Bravo", "c-Charlie", "e-Echo")
                        .toMap(data -> data.split("-")[0]); // 반환값은 Map의 key가 된다.

        single.subscribe(map -> Logger.log(LogType.ON_NEXT, map));
    }
}

// 실행 결과
onNext() | main | 23:09:41.986 | {a=a-Alpha, b=b-Bravo, c=c-Charlie, e=e-Echo}

// 파라미터가 2개
public class ObservableToMapExample02 {
    public static void main(String[] args) {
        Single<Map<String, String>> single = Observable.just("a-Alpha", "b-Bravo", "c-Charlie", "e-Echo")
                .toMap(
                    data -> data.split("-")[0],
                    data -> data.split("-")[1]
                );

        single.subscribe(map -> Logger.log(LogType.ON_NEXT, map));
    }
}

// 실행 결과
onNext() | main | 23:10:00.062 | {a=Alpha, b=Bravo, c=Charlie, e=Echo}
```

### 데이터 결합 연산자

**merge 연산자**

- 다수의 Observable에서 통지된 데이터를 받아서 다시 하나의 Observable로 통지한다.
- 통지 시점이 빠른 Observable의 데이터부터 순차적으로 통지되고, 통지 시점이 같을 경우에는 `merge()` 함수의 파라미터로 먼저 지정된 Observable의 데이터부터 통지된다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/b116736b-2c7a-4e60-aaa2-6a64b3a91a0d/Untitled.png)

```java
public class ObservableMergeExample01 {
    public static void main(String[] args) {
        Observable<Long> observable1 = Observable.interval(200L, TimeUnit.MILLISECONDS)
                .take(5);

        Observable<Long> observable2 = Observable.interval(400L, TimeUnit.MILLISECONDS)
                .take(5)
                .map(num -> num + 1000);

        Observable.merge(observable1, observable2)
                .subscribe(data -> Logger.log(LogType.ON_NEXT, data));

        TimeUtil.sleep(4000);
    }
}

// 실행 결과
onNext() | RxComputationThreadPool-1 | 23:42:40.652 | 0
onNext() | RxComputationThreadPool-1 | 23:42:40.811 | 1
onNext() | RxComputationThreadPool-2 | 23:42:40.815 | 1000
onNext() | RxComputationThreadPool-1 | 23:42:41.015 | 2
onNext() | RxComputationThreadPool-1 | 23:42:41.215 | 3
onNext() | RxComputationThreadPool-2 | 23:42:41.222 | 1001
onNext() | RxComputationThreadPool-1 | 23:42:41.411 | 4
onNext() | RxComputationThreadPool-2 | 23:42:41.620 | 1002
onNext() | RxComputationThreadPool-2 | 23:42:42.017 | 1003
onNext() | RxComputationThreadPool-2 | 23:42:42.420 | 1004
```

- 위 코드의 실행 결과를 표로 나타내면 아래와 같다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5ae2fe51-5b61-4371-9b50-a685a10ac0a9/Untitled.png)

**concat 연산자**

- 다수의 Observable에서 통지된 데이터를 받아서 다시 하나의 Observable로 통지한다.
- 하나의 Observable에서 통지가 끝나면 다음 Observable에서 연이어 통지가 된다.
- 각 Observable의 통지 시점과는 상관 없이 `concat()` 함수의 파라미터로 먼저 입력된 Observable의 데이터부터 모두 통지된 후, 다음 Observable의 데이터가 통지된다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c32fedc5-0b78-4bd3-95f8-9221c0177943/Untitled.png)

```java
public class ObservableConcatExample01 {
    public static void main(String[] args) {
        Observable<Long> observable1 =
                Observable.interval(500L, TimeUnit.MILLISECONDS)
                        .take(4);

        Observable<Long> observable2 =
                Observable.interval(300L, TimeUnit.MILLISECONDS)
                        .take(5)
                        .map(num -> num + 1000);

        Observable.concat(observable2, observable1)
                .subscribe(data -> Logger.log(LogType.ON_NEXT, data));

        TimeUtil.sleep(3500L);

    }
}

// 실행 결과
onNext() | RxComputationThreadPool-1 | 23:44:37.561 | 1000
onNext() | RxComputationThreadPool-1 | 23:44:37.832 | 1001
onNext() | RxComputationThreadPool-1 | 23:44:38.128 | 1002
onNext() | RxComputationThreadPool-1 | 23:44:38.432 | 1003
onNext() | RxComputationThreadPool-1 | 23:44:38.728 | 1004
onNext() | RxComputationThreadPool-2 | 23:44:39.237 | 0
onNext() | RxComputationThreadPool-2 | 23:44:39.736 | 1
onNext() | RxComputationThreadPool-2 | 23:44:40.237 | 2
onNext() | RxComputationThreadPool-2 | 23:44:40.738 | 3
```

**zip 연산자**

- 다수의 Observable에서 통지된 데이터를 받아서 다시 하나의 Observable로 통지한다.
- 각 Observable에서 통지된 데이터가 모두 모이면, 각 Observable에서 동일한 index의 데이터로 새로운 데이터를 생성한 후 통지한다.
- 통지하는 데이터 개수가 가장 적은 Observable의 통지 시점에 완료 통지 시점을 맞춘다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7113c545-dbf4-499e-b590-f54f5e60eb44/Untitled.png)

```java
public class ObservableZipExample01 {
    public static void main(String[] args) {
        Observable<Long> observable1 =
                Observable.interval(200L, TimeUnit.MILLISECONDS)
                        .take(4);

        Observable<Long> observable2 =
                Observable.interval(400L, TimeUnit.MILLISECONDS)
                        .take(6);

        Observable.zip(observable1, observable2, (data1, data2) -> data1 + data2)
                .subscribe(data -> Logger.log(LogType.ON_NEXT, data));

        TimeUtil.sleep(3000L);
    }
}

// 실행 결과
onNext() | RxComputationThreadPool-2 | 23:46:02.320 | 0
onNext() | RxComputationThreadPool-2 | 23:46:02.618 | 2
onNext() | RxComputationThreadPool-2 | 23:46:03.020 | 4
onNext() | RxComputationThreadPool-2 | 23:46:03.417 | 6
```

**combineLatest 연산자**

- 다수의 Observable에서 통지된 데이터를 받아서 다시 하나의 Observable로 통지한다.
- 각 Observable에서 데이터를 통지할 때마다 모든 Observable에서 마지막으로 통지한 각 데이터를 함수형 인터페이스에 전달하고, 새로운 데이터를 생성해 통지한다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/577163bb-5bba-4c7c-867f-779b2cb3cb5b/Untitled.png)

```java
public class ObservableCombineLatestExample01 {
    public static void main(String[] args) {
        Observable<Long> observable1 =
                Observable.interval(500L, TimeUnit.MILLISECONDS)=
                        .take(4);

        Observable<Long> observable2 =
                Observable.interval(700L, TimeUnit.MILLISECONDS)=
                        .take(4);

        Observable.combineLatest(
                observable1,
                observable2,
                (data1, data2) -> "data1: " + data1 + "\tdata2: " + data2)
                .subscribe(data -> Logger.log(LogType.ON_NEXT, data));

        TimeUtil.sleep(3000L);
    }
}

// 실행 결과
onNext() | RxComputationThreadPool-2 | 23:47:27.395 | data1: 0	data2: 0
onNext() | RxComputationThreadPool-1 | 23:47:27.664 | data1: 1	data2: 0
onNext() | RxComputationThreadPool-2 | 23:47:28.061 | data1: 1	data2: 1
onNext() | RxComputationThreadPool-1 | 23:47:28.164 | data1: 2	data2: 1
onNext() | RxComputationThreadPool-1 | 23:47:28.666 | data1: 3	data2: 1
onNext() | RxComputationThreadPool-2 | 23:47:28.765 | data1: 3	data2: 2
onNext() | RxComputationThreadPool-2 | 23:47:29.463 | data1: 3	data2: 3
```

### 에러 처리 연산자

**onErrorReturn 연산자**

- 에러가 발생했을 때 에러를 의미하는 데이터로 대체할 수 있다.
- `onErrorReturn()` 메서드를 호출하면 `onError` 이벤트는 발생하지 않는다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7ff74195-b446-46bb-9803-ef75aee5df6d/Untitled.png)

```java
public class ObservableOnErrorReturnExample {
    public static void main(String[] args) {
        Observable.just(5)
                .flatMap(num -> Observable
                        .interval(200L, TimeUnit.MILLISECONDS)
                        .take(5)
                        .map(i -> num / i)
                        .onErrorReturn(exception -> {
                            if(exception instanceof ArithmeticException)
                                Logger.log(LogType.PRINT, "계산 처리 에러 발생: " + exception.getMessage());

                            return -1L;
                        })
                )
                .subscribe(
                        data -> {
                            if(data < 0)
                                Logger.log(LogType.PRINT, "# 예외를 알리는 데이터: " + data);
                            else
                                Logger.log(LogType.ON_NEXT, data);
                        },
                        error -> Logger.log(LogType.ON_ERROR, error),
                        () -> Logger.log(LogType.ON_COMPLETE)
                );

        TimeUtil.sleep(1000L);
    }
}

// 실행 결과
print() | RxComputationThreadPool-1 | 15:52:40.916 | 계산 처리 에러 발생: / by zero
print() | RxComputationThreadPool-1 | 15:52:40.919 | # 예외를 알리는 데이터: -1
onComplete() | RxComputationThreadPool-1 | 15:52:40.919
```

**onErrorResumeNext 연산자**

- 에러가 발생했을 때 에러를 의미하는 Observable로 대체할 수 있다.
- Observable로 대체할 수 있으므로 데이터 교체와 더불어 에러 처리를 위한 추가 작업을 할 수 있다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/699cffbf-2a53-4f2b-8bf7-8ba721565e8a/Untitled.png)

```java
public class ObservableOnErrorResumeNextExample {
    public static void main(String[] args) {
        Observable.just(5L)
                .flatMap(num -> Observable
                        .interval(200L, TimeUnit.MILLISECONDS)
                        .take(5)
                        .map(i -> num / i)
                        .onErrorResumeNext(throwable -> {
                            Logger.log(LogType.PRINT, "# 운영자에게 이메일 발송: " + throwable.getMessage());
                            return Observable.interval(200L,TimeUnit.MILLISECONDS).take(5).skip(1).map(i -> num / i);
                        })
                ).subscribe(data -> Logger.log(LogType.ON_NEXT, data));

        TimeUtil.sleep(2000L);
    }
}

// 실행 결과
print() | RxComputationThreadPool-1 | 15:53:38.737 | # 운영자에게 이메일 발송: / by zero
onNext() | RxComputationThreadPool-2 | 15:53:39.148 | 5
onNext() | RxComputationThreadPool-2 | 15:53:39.347 | 2
onNext() | RxComputationThreadPool-2 | 15:53:39.546 | 1
onNext() | RxComputationThreadPool-2 | 15:53:39.747 | 1
```

**retry 연산자**

- 데이터 통지 중 에러가 발생했을 때, 데이터 통지를 재시도한다.
- 즉, `onError` 이벤트가 발생하면 `subscribe()`를 다시 호출하여 재구독한다.
- 에러가 발생한 시점에 통지에 실패한 데이터만 다시 통지되는 것이 아니라 처음부터 다시 통지된다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/1b3eac7d-50c6-4604-8c57-e222a92c14a4/Untitled.png)

```java
public class ObservableRetryExample03 {

    public static void main(String[] args) {
        Observable.just(10, 12, 15, 16)
                .zipWith(Observable.just(1, 2, 0, 4), (a, b) -> {
                    int result;
                    try{
                        result = a / b;
                    }catch(ArithmeticException ex){
                        Logger.log(LogType.PRINT, "error: " + ex.getMessage());
                        throw ex;
                    }
                    return result;
                })
                .retry(3)
                .onErrorReturn(throwable -> -1)
                .subscribe(
                data -> Logger.log(LogType.ON_NEXT, data),
                error -> Logger.log(LogType.ON_ERROR, error),
                () -> Logger.log(LogType.ON_COMPLETE)
        );

        TimeUtil.sleep(5000L);
    }
}

// 실행 결과
onNext() | main | 15:55:05.956 | 10
onNext() | main | 15:55:05.958 | 6
print() | main | 15:55:05.959 | error: / by zero
onNext() | main | 15:55:05.962 | 10
onNext() | main | 15:55:05.962 | 6
print() | main | 15:55:05.963 | error: / by zero
onNext() | main | 15:55:05.963 | 10
onNext() | main | 15:55:05.963 | 6
print() | main | 15:55:05.963 | error: / by zero
onNext() | main | 15:55:05.963 | 10
onNext() | main | 15:55:05.963 | 6
print() | main | 15:55:05.963 | error: / by zero
onNext() | main | 15:55:05.963 | -1
onComplete() | main | 15:55:05.963
```

- `zipWith()` 메서드는 다른 Observable과 결합하는 역할을 하는데, 같은 인덱스에 있는 요소끼리 결합하여 람다로 들어온 작업을 수행한다. 위 코드에서는 나눗셈 작업을 한다.
- 에러가 발생하면 3번 다시 시도하는 것을 알 수 있다. 그리고 3번 재시도하더라도 에러가 발생했다면 -1을 소비자에게 전달하였다.

### 유틸리티 연산자

**delay 연산자 - 첫 번째 유형**

- 생산자가 데이터를 생성 및 통지를 하지만, 설정한 시간만큼 소비자 쪽으로의 데이터 전달을 지연시킨다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/672fe736-99fb-441c-96b0-a98bb194f912/Untitled.png)

```java
public class ObservableDelayExample01 {
    public static void main(String[] args) {
        Logger.log(LogType.PRINT, "# 실행 시작 시간: " + TimeUtil.getCurrentTimeFormatted());

        Observable.just(1, 3, 4, 6)
                .doOnNext(data -> Logger.log(LogType.DO_ON_NEXT, data))
                .delay(2000L, TimeUnit.MILLISECONDS)
                .subscribe(data -> Logger.log(LogType.ON_NEXT, data));

        TimeUtil.sleep(2500L);
    }
}

// 실행 결과
print() | main | 22:49:05.324 | # 실행 시작 시간: 22:49:05.321
doOnNext() | main | 22:49:05.475 | 1
doOnNext() | main | 22:49:05.479 | 3
doOnNext() | main | 22:49:05.479 | 4
doOnNext() | main | 22:49:05.479 | 6
onNext() | RxComputationThreadPool-1 | 22:49:07.483 | 1
onNext() | RxComputationThreadPool-1 | 22:49:07.484 | 3
onNext() | RxComputationThreadPool-1 | 22:49:07.485 | 4
onNext() | RxComputationThreadPool-1 | 22:49:07.485 | 6
```

**delay 연산자 - 두 번째 유형**

- 파라미터로 생성되는 Observable이 데이터를 통지할 때까지 각각의 원본 데이터의 통지를 지연시킨다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/cb7d99e1-00b4-455c-bcbd-13b4cd684078/Untitled.png)

```java
public class ObservableDelayExample02 {
    public static void main(String[] args) {
        Observable.just(1,3,5,7)
                .delay(item -> {
                    TimeUtil.sleep(1000L);
                    return Observable.just(item); // 새로운 Observable의 통지 시점에, 원본 데이터를 통지한다.
                }).subscribe(data -> Logger.log(LogType.ON_NEXT, data));
    }
}

// 실행 결과
onNext() | main | 22:52:17.054 | 1
onNext() | main | 22:52:18.063 | 3
onNext() | main | 22:52:19.069 | 5
onNext() | main | 22:52:20.072 | 7
```

**delaySubscription 연산자**

- 생산자가 데이터의 생성 및 통지 자체를 설정한 시간만큼 지연시킨다.
- 즉, 소비자가 구독을 해도 구독 시점 자체가 지연된다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/41bafaa5-3bd6-46f9-9d97-93e7cbc19c18/Untitled.png)

```java
public class ObservableDelaySubscriptionExample {
    public static void main(String[] args) {
        Logger.log(LogType.PRINT, "# 실행 시작 시간: " + TimeUtil.getCurrentTimeFormatted());

        Observable.just(1, 3, 4, 6)
                .doOnNext(data -> Logger.log(LogType.DO_ON_NEXT, data))
                .delaySubscription(2000L, TimeUnit.MILLISECONDS)
                .subscribe(data -> Logger.log(LogType.ON_NEXT, data));

        TimeUtil.sleep(2500L);
    }
}

// 실행 결과
print() | main | 22:56:12.975 | # 실행 시작 시간: 22:56:12.972
doOnNext() | RxComputationThreadPool-1 | 22:56:15.248 | 1
onNext() | RxComputationThreadPool-1 | 22:56:15.249 | 1
doOnNext() | RxComputationThreadPool-1 | 22:56:15.249 | 3
onNext() | RxComputationThreadPool-1 | 22:56:15.249 | 3
doOnNext() | RxComputationThreadPool-1 | 22:56:15.249 | 4
onNext() | RxComputationThreadPool-1 | 22:56:15.249 | 4
doOnNext() | RxComputationThreadPool-1 | 22:56:15.249 | 6
onNext() | RxComputationThreadPool-1 | 22:56:15.249 | 6
```

**timeout 연산자**

- 각각의 데이터 통지 시, 지정된 시간 안에 통지가 되지 않으면 에러를 통지한다.
- 에러 통지 시 전달되는 에러 객체는 TimeoutException이다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/de21d4dd-56e5-410b-a012-de88e0828f82/Untitled.png)

```java
public class ObservableTimeOutExample {
    public static void main(String[] args) {
        Observable.range(1, 5)
                .map(num -> {
                    long time = 1000L;
                    if(num == 4){
                        time = 1500L;
                    }
                    TimeUtil.sleep(time);
                    return num;
                })
                .timeout(1200L, TimeUnit.MILLISECONDS)
                .subscribe(
                        data -> Logger.log(LogType.ON_NEXT, data),
                        error -> Logger.log(LogType.ON_ERROR, error)
                );

        TimeUtil.sleep(4000L);
    }
}

// 실행 결과
onNext() | main | 22:57:34.211 | 1
onNext() | main | 22:57:35.220 | 2
onNext() | main | 22:57:36.226 | 3
onERROR() | RxComputationThreadPool-1 | 22:57:37.433 | java.util.concurrent.TimeoutException: The source did not signal an event for 1200 milliseconds and has been terminated.
```

**timeInterval 연산자**

- 각각의 데이터가 통지되는데 걸린 시간을 통지한다.
- 통지된 데이터와 데이터가 통지되는데 걸린 시간은 소비자 쪽에서 모두 처리할 수 있다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/4dabfc26-85c0-40d7-b743-bf0ecd34bce8/Untitled.png)

```java
public class ObservableTimeIntervalExample {
    public static void main(String[] args) {
        Observable.just(1, 3, 5, 7, 9)
                .delay(item -> {
                    TimeUtil.sleep(NumberUtil.randomRange(100, 1000));
                    return Observable.just(item);
                })
                .timeInterval()
                .subscribe(
                        timed -> Logger.log(LogType.ON_NEXT, "# 통지하는데 걸린 시간: " + timed.time() + "\t# 통지된 데이터: " + timed.value())
                );
    }
}

// 실행 결과
onNext() | main | 22:59:07.557 | # 통지하는데 걸린 시간: 942	# 통지된 데이터: 1
onNext() | main | 22:59:08.018 | # 통지하는데 걸린 시간: 570	# 통지된 데이터: 3
onNext() | main | 22:59:08.828 | # 통지하는데 걸린 시간: 810	# 통지된 데이터: 5
onNext() | main | 22:59:09.233 | # 통지하는데 걸린 시간: 405	# 통지된 데이터: 7
onNext() | main | 22:59:10.123 | # 통지하는데 걸린 시간: 890	# 통지된 데이터: 9
```

**materialize / dematerialize 연산자**

- materialize: 통지된 데이터와 통지된 데이터의 통지 타입 자체를 Notification 객체에 담고 이 Notification 객체를 통지한다. 즉, 통지 데이터의 메타 데이터를 포함해서 통지한다고 볼 수 있다.
- dematerialize: 통지된 Notification 객체를 원래의 통지 데이터로 변환해서 통지한다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/4ffc59ab-57b8-4a3f-91b9-79f9c3a58934/Untitled.png)

```java
public class ObservableMaterialExample02 {
    public static void main(String[] args) {
        Observable.concatEager(
                Observable.just(
                        getDBUser().subscribeOn(Schedulers.io()),
                        getAPIUser()
                                .subscribeOn(Schedulers.io())
                                .materialize()
                                .map(notification -> {
                                    if (notification.isOnError()) {
                                        // 관리자에게 에러 발생을 알림
                                        Logger.log(LogType.PRINT, "# API user 에러 발생!");
                                    }
                                    return notification;
                                })
                                .filter(notification -> !notification.isOnError())
                                .dematerialize(notification -> notification)
                )
        ).subscribe(
                data -> Logger.log(LogType.ON_NEXT, data),
                error -> Logger.log(LogType.ON_ERROR, error),
                () -> Logger.log(LogType.ON_COMPLETE)
        );

        TimeUtil.sleep(1000L);
    }

    private static Observable<String> getDBUser() {
        return Observable.fromIterable(Arrays.asList("DB user1", "DB user2", "DB user3", "DB user4", "DB user5"));
    }

    private static Observable<String> getAPIUser() {
        return Observable
                .just("API user1", "API user2", "Not User", "API user4", "API user5")
                .map(user -> {
                    if(user.equals("Not User"))
                        throw new RuntimeException();
                    return user;
                });
    }
}

// 실행 결과
onNext() | main | 23:02:24.678 | DB user1
print() | RxCachedThreadScheduler-1 | 23:02:24.678 | # API user 에러 발생!
onNext() | main | 23:02:24.682 | DB user2
onNext() | main | 23:02:24.682 | DB user3
onNext() | main | 23:02:24.682 | DB user4
onNext() | main | 23:02:24.682 | DB user5
onNext() | main | 23:02:24.682 | API user1
onNext() | main | 23:02:24.682 | API user2
onComplete() | main | 23:02:24.682
```

### 조건과 불린 연산자

**all 연산자**

- 통지되는 모든 데이터가 설정한 조건에 맞는지를 판단한다.
- 결과 값을 한 번만 통지하면 되기 때문에 true/false 값을 Single로 반환한다.
- 통지된 데이터가 조건에 맞지 않는다면 이후 데이터는 구독 해지되어 통지되지 않는다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/eeeb67e0-928f-4777-ac6e-4a5bd838812d/Untitled.png)

```java
public class ObservableAllExample {
    public static void main(String[] args) {
        Observable.fromIterable(SampleData.carList)
                .doOnNext(car -> Logger.log(LogType.DO_ON_NEXT, "Car Maker: " + car.getCarMaker() +
                        ", \tCar Name: " + car.getCarName()))
                .map(car -> car.getCarMaker())
                .all(carMaker -> carMaker.equals(CarMaker.CHEVROLET))
                .subscribe(data -> Logger.log(LogType.ON_NEXT, data));
    }
}

// 실행 결과
doOnNext() | main | 23:26:39.974 | Car Maker: CHEVROLET, 	Car Name: 말리부
doOnNext() | main | 23:26:39.977 | Car Maker: HYUNDAE, 	Car Name: 쏘렌토
onNext() | main | 23:26:39.978 | false
```

**amb 연산자**

- 여러 개의 Observable 중에서 최초 통지 시점이 가장 빠른 Observable의 데이터만 통지되고, 나머지 Observable은 무시된다.
- 즉, 가장 먼저 통지를 시작한 Observable의 데이터만 통지된다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/0eec4d3b-4137-46bb-b995-e8168f10d188/Untitled.png)

```java
public class ObservableAmbExample {
    public static void main(String[] args) {

        List<Observable<Integer>> observables = Arrays.asList(
                Observable.fromIterable(SampleData.salesOfBranchA)
                        .delay(200L, TimeUnit.MILLISECONDS)
                        .doOnComplete(() -> Logger.log(LogType.DO_ON_COMPLETE, "# branch A's sales")),
                Observable.fromIterable(SampleData.salesOfBranchB)
                        .delay(300L, TimeUnit.MILLISECONDS)
                        .doOnComplete(() -> Logger.log(LogType.DO_ON_COMPLETE, "# branch B's sales")),
                Observable.fromIterable(SampleData.salesOfBranchC)
                        .delay(500L, TimeUnit.MILLISECONDS)
                        .doOnComplete(() -> Logger.log(LogType.DO_ON_COMPLETE, "# branch C's sales"))
        );

        Observable.amb(observables)
                .doOnComplete(() -> Logger.log(LogType.DO_ON_COMPLETE, "# 완료"))
                .subscribe(data -> Logger.log(LogType.ON_NEXT, data));

        TimeUtil.sleep(1000L);
    }
}

// 실행 결과
onNext() | RxComputationThreadPool-1 | 23:28:20.367 | 10000000
onNext() | RxComputationThreadPool-1 | 23:28:20.367 | 35000000
onNext() | RxComputationThreadPool-1 | 23:28:20.367 | 23000000
onNext() | RxComputationThreadPool-1 | 23:28:20.367 | 40000000
onNext() | RxComputationThreadPool-1 | 23:28:20.367 | 50000000
onNext() | RxComputationThreadPool-1 | 23:28:20.367 | 45000000
onNext() | RxComputationThreadPool-1 | 23:28:20.367 | 35000000
onNext() | RxComputationThreadPool-1 | 23:28:20.367 | 23000000
onNext() | RxComputationThreadPool-1 | 23:28:20.367 | 15000000
onNext() | RxComputationThreadPool-1 | 23:28:20.367 | 10000000
doOnComplete() | RxComputationThreadPool-1 | 23:28:20.368 | # branch A's sales
doOnComplete() | RxComputationThreadPool-1 | 23:28:20.368 | # 완료
```

**contains 연산자**

- 파라미터의 데이터가 Observable에 포함되어 있는지를 판단한다.
- 결과 값을 한 번만 통지하면 되기 때문에 true/false 값을 Single로 반환한다.
- 결과 통지 시점은 Observable에 포함된 데이터를 통지하거나 완료를 통지할 때이다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7bc1624c-f3b8-49f3-9df9-28cd089ba4d7/Untitled.png)

```java
public class ObservableContainsExample {
    public static void main(String[] args) {
        Observable.fromArray(SampleData.carMakersDuplicated)
                .doOnNext(data -> Logger.log(LogType.DO_ON_NEXT, data))
                .contains(CarMaker.SAMSUNG)
                .subscribe(data -> Logger.log(LogType.ON_NEXT, data));
    }
}

// 실행 결과
doOnNext() | main | 23:30:05.679 | CHEVROLET
doOnNext() | main | 23:30:05.682 | HYUNDAE
doOnNext() | main | 23:30:05.682 | SAMSUNG
onNext() | main | 23:30:05.682 | true
```

**defaultIfEmpty 연산자**

- 통지할 데이터가 없을 경우 파라미터로 입력된 값을 통지한다.
- 즉, 연산자 이름 의미 그대로 Observable에 통지할 데이터가 없이 비어 있는 상태일 때 디폴트 값을 통지한다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/842ec9bb-a36c-4350-ac9c-6f8dc9043901/Untitled.png)

```java
public class ObservableDefaultIfEmptyExample {
    public static void main(String[] args) {
        Observable.just(1, 2, 3, 4, 5)
                .filter(num -> num > 10)
                .defaultIfEmpty(10)
                .subscribe(data -> Logger.log(LogType.ON_NEXT, data));
    }
}

// 실행 결과
onNext() | main | 23:31:22.254 | 10
```

**sequenceEqual 연산자**

- 두 Observable이 동일한 순서로 동일한 개수의 같은 데이터를 통지하는지 판단한다.
- 통지 시점과 무관하게 데이터의 정합성만 판단하므로 통지 시점이 다르더라도 조건이 맞다면 true를 통지한다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e3b74375-832e-48a0-a320-3ee084c9de27/Untitled.png)

```java
public class ObservableSequenceEqualExample {
    public static void main(String[] args) {
        Observable<CarMaker> observable1 =
                Observable
                        .fromArray(SampleData.carMakers)
                        .subscribeOn(Schedulers.computation())
                        .delay(carMaker -> {
                            TimeUtil.sleep(500L);
                            return Observable.just(carMaker);
                        }).doOnNext(data -> Logger.log(LogType.DO_ON_NEXT, "# observable1 : " + data));

        Observable<CarMaker> observable2 =
                Observable
                        .fromArray(SampleData.carMakersDuplicated)
                        .delay(carMaker -> {
                            TimeUtil.sleep(1000L);
                            return Observable.just(carMaker);
                        }).doOnNext(data -> Logger.log(LogType.DO_ON_NEXT, "# observable2 : " + data));

        Observable.sequenceEqual(observable1, observable2)
                .subscribe(data -> Logger.log(LogType.ON_NEXT, data));
    }
}

// 실행 결과
doOnNext() | RxComputationThreadPool-1 | 23:32:49.667 | # observable1 : CHEVROLET
doOnNext() | main | 23:32:50.020 | # observable2 : CHEVROLET
doOnNext() | RxComputationThreadPool-1 | 23:32:50.177 | # observable1 : HYUNDAE
doOnNext() | RxComputationThreadPool-1 | 23:32:50.682 | # observable1 : SAMSUNG
doOnNext() | main | 23:32:51.022 | # observable2 : HYUNDAE
doOnNext() | RxComputationThreadPool-1 | 23:32:51.188 | # observable1 : SSANGYOUNG
doOnNext() | RxComputationThreadPool-1 | 23:32:51.689 | # observable1 : KIA
doOnNext() | main | 23:32:52.024 | # observable2 : SAMSUNG
doOnNext() | main | 23:32:53.030 | # observable2 : SSANGYOUNG
doOnNext() | main | 23:32:54.032 | # observable2 : CHEVROLET
onNext() | main | 23:32:54.035 | false
doOnNext() | main | 23:32:55.040 | # observable2 : HYUNDAE
doOnNext() | main | 23:32:56.046 | # observable2 : KIA
doOnNext() | main | 23:32:57.051 | # observable2 : SSANGYOUNG
```

### 데이터 집계 연산자

**count 연산자**

- Observable이 통지한 데이터의 총 개수를 통지한다.
- 총 개수만 통지하면 되므로 결과 값은 Single로 반환한다.
- 데이터의 총 개수를 통지하는 시점은 완료 통지를 받은 시점이다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/a4ad5744-2ad3-45d9-bd30-46465a382dc5/Untitled.png)

```java
public class ObservableCountExample01 {
    public static void main(String[] args) {
        Observable.fromIterable(SampleData.carList)
                .count()
                .subscribe(data -> Logger.log(LogType.ON_NEXT, data));
    }
}

// 실행 결과
onNext() | main | 23:53:50.724 | 9
```

**reduce 연산자**

- Observable이 통지한 데이터를 이용해서 어떤 결과를 일정한 방식으로 합성한 후, 최종 결과를 반환한다.
- Observable이 통지한 데이터가 숫자일 경우 파라미터로 지정한 함수형 인터페이스에 정의된 계산 방식으로 값을 집계할 수 있다.
