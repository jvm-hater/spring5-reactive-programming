- 하나의 프로젝트에서 여러 개의 리액티브 라이브러리를 사용했을 때 발생하는 문제에 대해 다룬다.
- 리액티브 시스템에서 배압 제어에 대해 깊이 있게 다룬다.
- 위의 문제를 RxJava에서 제시한 해결 방법과 그 한계를 검토해 본다.

# 1️⃣ 모두를 위한 반응성

## 1) 풀 방식과 푸시 방식

- 리액티브 초기 단계에서 모든 라이브러리의 데이터 흐름은 소스에서 구독자에게 푸시되는 방식이었다.
    - 풀 방식으로 요소를 하나씩 요청할 경우 비동기 논블로킹 방식을 사용하더라도 각 요소에 대한 요청을 처리 하면서 대기시간이 발생하여 전체 처리시간 중 많은 시간을 유휴 상태로 있게 된다.
- 푸시 방식을 도입하면서 요청하는 횟수를 최소화하여 전체 처리 시간을 최적화할 수 있다.

## 2) 흐름 제어

- 앞에서 설명했듯이, 푸시 모델을 채택하는 가장 중요한 이유는 요청하는 횟수를 최소화해 전체 처리 시간을 최적화하는 것이다.
- 그러나 푸시 모델만 사용하는 것으로는 기술적 한계가 있다.
    - 메시지 기반 통신의 본질은 `요청에 응답하는 것`인데, 프로듀서가 컨슈머의 처리 능력을 무시하면 전반적인 시스템 안정성에 영향을 미칠 수 있기 때문이다.

## 3) 느린 프로듀서와 빠른 컨슈머

- 이러한 상황은 알려지지 않은 컨슈머의 능력에 대해 프로듀서가 믿지 못하는 경우 발생할 수 있다.
- 순수한 푸시 모델은 동적으로 시스템의 처리량을 증가시키는 것이 불가능하다.

## 4) 빠른 프로듀서와 느린 컨슈머

- 여기서 문제는 프로듀서가 컨슈머가 처리할 수 있는 것보다 훨씬 많은 데이터를 전송할 수 있으며 이로 인해 부하를 받는 컴포넌트에 치명적인 오류가 발생할 수 있다는 것이다.
- 이러한 경우 직관적인 솔루션은 처리되지 않은 원소를 큐에 수집하는 것으로, 큐는 프로듀서와 컨슈머 사이에 있을 수도 있고 컨슈머 측에 있을 수도 있다.
- 큐를 사용해 푸시된 데이터를 처리할 때 중요한 것 중 하나는 적절한 특성을 가진 큐를 선택하는 것이다.
    1. 무제한 큐
        1. 큐의 사이즈를 제한하지 않는 형태이다.
        2. 메시지 전달에 대해 확신할 수 있다.
        3. 메모리 한도에 도달하면 전체 시스템이 손상될 가능성이 있다. (복원력이 떨어짐)
    2. 크기가 제한된 드롭 큐
        1. 큐가 가득차면 신규 유입된 메시지를 무시하는 형태이다.
        2. 메시지의 중요성이 낮을 때 사용되는 방법이다.
    3. 크기가 제한된 블로킹 큐
        1. 앞의 기술은 각 메시지가 중요한 경우에는 사용하지 못할 수가 있다. (결제 시스템 같은 경우)
        2. 큐의 한계에 도달하면 컨슈머가 요소를 처리해 큐의 여유 공간이 생길 때까지 차단 상태가 된다.
            1. 가장 느린 컨슈머의 처리량에 의해 시스템의 전체 처리량이 제한된다. 
            2. 시스템의 비동기 동작을 모두 무효화하는 것과 함께 리소스를 효율적으로 사용하지 못한다.

---

# 2️⃣ 리액티브 스트림의 기본 스펙

리액티브 스트림 스펙에는 `Publisher`, `Subscriber`, `Subscription`, `Processor`의 네 가지 기본 인터페이스가 정의돼 있다.

## 1) Publisher

```java
public interface Publisher<T> {
    public void subscribe(Subscriber<? super T> s);
}
```

- Observable과 비교하면 Publisher와 Subscriber를 연결하기 위한 표준화된 진입점을 의미한다.

## 2) Subscriber

```java
public interface Subscriber<T> {
    public void onSubscribe(Subscription s);
    public void onNext(T t);
    public void onError(Throwable t);
    public void onComplete();
}
```

- RxJava의 Observer와 달리 `onSubscribe`라는 새로운 추가 메소드를 제공한다.
- `onSubcribe()` 메서드는 Subscriber에게 구독이 성공했음을 알려준다. 매개변수로는 Subscription 클래스를 사용한다.

## 3) Subscription

```java
public interface Subscription {
    public void request(long n);
    public void cancel();
}
```

- Subscription은 원소 생성을 제어하기 위해 기본적인 사항을 제공한다.
- `cancel()` 메소드가 있어서 스트림에서 구독을 취소하거나 발행을 완전히 취소할 수 있다.
- `request()` 메서드를 통해 프로듀서가 보내줘야 하는 데이터 크기를 알려줘, 컨슈머에 유입되는 원소의 개수를 제한할 수 있다.

![image](https://user-images.githubusercontent.com/55661631/199280910-2021dbbe-e646-4541-9511-d7dbdffe445b.png)

- 위 그림은 기본 매커니즘을 이해하기 위한 마블 다이어그램이다.
- Publisher는 Subscriber가 요청한 경우에만 원소의 새 부분을 보내도록 보장한다.
- Publisher의 전체 구현은 순수한 블로킹 방식으로 대기하는 방식부터 Subscriber의 요청에 대해서만 데이터를 생성하는 위 그림과 같은 매커니즘으로 다양하게 있다.
- `request()` 메서드라는 보증 수단이 있으므로 큐가 필요없다.

리액티브 스트림은 동적 푸시-풀 모델과 함께 푸시 모델과 풀 모델도 지원한다.

- 순수 푸시 모델
    - 처음부터 최대 개수 요소를 요청한다. `request(Long.MAX_VALUE)`
- 순수 풀 모델
    - `onNext()`가 호출 될 때마다 데이터를 한 개씩 요청하면 된다.

## 4) Processor

```java
public interface Processor<T, R> extends Subscriber<T>, Publisher<R> {
}
```

- Processor는 Publisher와 Subscriber의 혼합 형태이다.
- Processor는 일부 변환 로직을 구현하여 스트리밍 파이프라인 역할을 할 수 있고 비즈니스 로직 흐름을 더 쉽게 이해할 수 있다.
- 사용 예시
    - 커스텀 연산자로 구현할 수 있는 비즈니스 로직
    - 스트리밍 데이터의 추가 캐싱

---

# 3️⃣ 리액티브 스트림을 활용한 비동기 및 병렬 처리

- 리액티브 스트림 API는 Publisher가 생성하고 Susbscriber가 소비한 모든 신호는 처리 중에 논블로킹이어야 하며 방해받지 않아야 한다고 명시돼 있다.
- 모든 프로세서나 코어를 효율적으로 사용하려면 병렬 처리가 필요한데, 리액티브 스트림 스펙 내의 병렬화 개념은 일반적으로 `Subscriber#onNext` 메서드를 병렬로 호출하는 것을 뜻한다.
- 그러나 `on****` 메서드의 호출은 **‘스레드 안전성을 보장하는 방식으로 신호를 보내야 하며, 다중 스레드에서 수행되는 경우 외부적인 동기화를 사용해야 한다’**고 명시하고 있다.
- 따라서 직렬화되거나 순차적인 `on****` 메서드의 호출을 전제로 해야 한다. (ParallelPublisher와 같은 것을 만들 수 없고, 스트림의 요소를 병렬 처리할 수 없다는 것을 의미)
- 따라서 아래 예제처럼 스트림 처리 파이프를 독립적인 스레드에 할당하여 자원을 효율적으로 활용해야 한다.
    - **원본 리소스가 목적지 리소스보다 더 적게 로드될 때**
        
        ```java
        소스   →   필터 → (이외 작업들) → 맵   →   목적지
        (              스레드 A             ) (스레드 B)
        ```
        
    
    - **목적지 리소스가 원본 리소스보다 더 적게 로드될 때**
        
        ```java
        소스   →   필터 → (이외 작업들) → 맵   →   목적지
        (스레드 A) (             스레드 B             )
        ```
        
    
    - **메시지 생산과 소비가 모두 CPU 집약적인 작업일 때**
        
        ```java
        소스   →   필터   →   (이외 작업들)   →   맵   →   목적지
        (스레드 1) (스레드 2)   ( ... )    (스레드 N-1) (스레드 N)
        ```
